<script>
  console.log("je suis la");

  function _updateValue(path, value, /** @type {HTMLElement} */ componentEl) {
    componentEl
      .querySelectorAll(
        CustomAttribute.getQuerySelector(CustomAttribute.TEXT, path)
      )
      .forEach((el) => (el.innerHTML = value));
    componentEl
      .querySelectorAll(
        CustomAttribute.getQuerySelector(CustomAttribute.MODEL, path)
      )
      .forEach((el) => (el.innerHTML = value));
  }

  function registerEvents(){
    Object.keys(Events).forEach((eventName) => {
      const eventData = Events[eventName];
      const elements = this.componentEl.querySelectorAll(`[r-${eventName}]`);
      console.log({ elements });
      elements.forEach((element) => {
        console.log("add listender", eventData);

        element.addEventListener(eventData.HtmlEventName, (event) => {
          if (eventData.action) eventData.action(event);
          const functionNameAndArgs = element.getAttribute(`r-${eventName}`);
          const args = functionNameAndArgs.split(",");
          const functionName = args.splice(0, 1).at(0);

          //TODO: ajouter un system pour recupÃ©rer l'event (via un args $e par exemple et le choper ici pour le remplacer par l'event)

          if (this.HTMLActionsList[functionName]) {
            this.HTMLActionsList[functionName](...args);
          } else {
            console.warn(
              `No function found with the name "${functionName}", please add it before with component this.addHTMLAction function `
            );
          }
        });
      });
    });
  }

  function registerModels() {
    const models = this.componentEl.querySelectorAll(`[r-model]`);
    console.log({ that: this, models });
    models.forEach((modelEl) => {
      const fnId = crypto.randomUUID();
      this.addHTMLAction(fnId, () => {
        const refNameAndProp = modelEl.getAttribute("r-model").split(".");
        if (Object.hasOwn(this.refsList, refNameAndProp[0])) {
          if (
            Object.hasOwn(this.refsList[refNameAndProp[0]], refNameAndProp[1])
          ) {
            this.refsList[refNameAndProp[0]][refNameAndProp[1]] =
              event.target.value;
          } else {
            console.warn(
              `Property ${refNameAndProp[1]} not found in ref ${refNameAndProp[0]}`
            );
          }
        } else {
          console.warn(`Ref with name ${refNameAndProp[0]} not found`);
        }
      });
      modelEl.setAttribute("r-input", fnId);
      modelEl.setAttribute("r-value", modelEl.getAttribute("r-model"));
    });
  }

  function refFn(name, rawValue) {
    if (Object.keys(this.refsList).find((refName) => refName === name)) {
      throw new Error("cant redeclare ref with same name");
    }
    console.log({ rawValue });
    let value = {};

    // value = {}
    // for (const key in rawValue) {
    //     if (Object.hasOwnProperty.call(rawValue, key)) {
    //         const element = rawValue[key];
    //         value[key] = ref(element)
    //     }
    // }
    const componentElement = this.componentEl
    const proxy = new Proxy(rawValue, {
      get(target, p, receiver) {
        return target[p];
      },
      set(target, p, newValue, receiver) {
        //update dom
        CustomAttribute.TEXT.updateAll(
          componentElement,
          `${name}.${p}`,
          newValue
        );
        CustomAttribute.MODEL.updateAll(
          componentElement,
          `${name}.${p}`,
          newValue
        );
        CustomAttribute.VALUE.updateAll(
          componentElement,
          `${name}.${p}`,
          newValue
        );
        target[p] = newValue;
        return true;
      },
    });
    this.refsList[name] = proxy;
    return this.refsList[name];
  }

  const Events = {
    click: {
      HtmlEventName: "click",
    },
    input: {
      HtmlEventName: "input",
    },
    submit: {
      HtmlEventName: "submit",
      action: (e) => e.preventDefault(),
    },
  };

  const CustomAttribute = {
    getQuerySelector: (customAttribute, value) =>
      `[${customAttribute.key}="${path}"]`,

    TEXT: {
      key: "r-text",
      getQuerySelector: (path) => `[r-text="${path}"]`,
      updateAll: (componentEl, path, value) => {
        componentEl
          .querySelectorAll(`[r-text="${path}"]`)
          .forEach((el) => (el.innerHTML = value));
      },
    },
    VALUE: {
      key: "r-value",
      updateAll: (componentEl, path, value) => {
        componentEl
          .querySelectorAll(`[r-value="${path}"]`)
          .forEach((el) => (el.value = value));
      },
    },
    MODEL: {
      key: "r-model",
      getQuerySelector: (path) => `[r-model="${path}"]`,
      updateAll: (componentEl, path, value) => {
        componentEl
          .querySelectorAll(`[r-model="${path}"]`)
          .forEach((el) => (el.innerHTML = value));
      },
    },
  };

  function composant(scriptEl, setup) {
    this.refsList = {};

    /** @type {HTMLElement} */
    this.componentEl = scriptEl.parentElement;


    this.HTMLActionsList = {};
    this.addHTMLAction = (name, actionFn) => {
      this.HTMLActionsList[name] = actionFn;
    };
    this.refFn = refFn.bind(this)

    registerModels.bind(this)();
    registerEvents.bind(this)();

    const data = JSON.parse(
      decodeURIComponent(this.componentEl.dataset["data"])
    );

    this.componentEl.dashyboard = {};
    this.componentEl.dashyboard.data = data;

    const appContext = {
      updateValue: (id, value) => _updateValue(id, value, this.componentEl),
      onMount: (callback) => onMountsFn.push(callback),
      ref:this.refFn,
      addHTMLAction: this.addHTMLAction,
    };
    const onMountsFn = [];

    const setupData = setup(data, appContext);
    window.addEventListener("DOMContentLoaded", () => {
      window.WebSocketService.waitSocket((socket) => {
        onMountsFn.forEach((callback) => callback({ socket }));
      });
    });
  }

</script>
